package action

import (
	"fmt"
	"strings"

	"github.com/poppolopoppo/ppb/internal/base"
	internal_io "github.com/poppolopoppo/ppb/internal/io"

	//lint:ignore ST1001 ignore dot imports warning
	. "github.com/poppolopoppo/ppb/utils"
)

var LogAction = base.NewLogCategory("Action")

func InitAction() {
	base.LogTrace(LogAction, "build/action.Init()")

	base.RegisterSerializable(&ActionRules{})
	base.RegisterSerializable(&actionCache{})
}

/***************************************
 * ActionFlags
 ***************************************/

type ActionFlags struct {
	CacheCompression      base.CompressionFormat
	CacheCompressionLevel base.CompressionLevel
	CacheMode             CacheModeType
	CachePath             Directory
	DistMode              DistModeType
	ResponseFile          BoolVar
	ShowCmds              BoolVar
	ShowFiles             BoolVar
	ShowOutput            BoolVar
}

func (x *ActionFlags) Flags(cfv CommandFlagsVisitor) {
	cfv.Persistent("CacheMode", "use input hashing to store/retrieve action outputs", &x.CacheMode)
	cfv.Persistent("CachePath", "set path used to store cached actions", &x.CachePath)
	cfv.Persistent("CacheCompression", "set compression format for cached bulk entries", &x.CacheCompression)
	cfv.Persistent("CacheCompressionLevel", "set compression level for cached bulk entries", &x.CacheCompressionLevel)
	cfv.Persistent("DistMode", "distribute actions to a cluster of remote workers", &x.DistMode)
	cfv.Persistent("ResponseFile", "control response files usage", &x.ResponseFile)
	cfv.Variable("ShowCmds", "print executed compilation commands", &x.ShowCmds)
	cfv.Variable("ShowFiles", "print file accesses for external commands", &x.ShowFiles)
	cfv.Variable("ShowOutput", "always show compilation commands output", &x.ShowOutput)
}

var GetActionFlags = NewCommandParsableFlags(&ActionFlags{
	CacheMode: CACHE_NONE,
	CachePath: UFS.Cache,
	// Lz4 is almost as fast as uncompressed, but with fewer IO: when using Fast speed it is almost always a free win
	CacheCompression:      base.COMPRESSION_FORMAT_LZ4,
	CacheCompressionLevel: base.COMPRESSION_LEVEL_FAST,

	DistMode: DIST_NONE,

	ResponseFile: base.INHERITABLE_TRUE,
	ShowCmds:     base.INHERITABLE_FALSE,
	ShowFiles:    base.INHERITABLE_FALSE,
	ShowOutput:   base.INHERITABLE_FALSE,
})

/***************************************
 * Action Rules
 ***************************************/

type Action interface {
	GetAction() *ActionRules
	DependsOn(actions ...Action)
	Buildable
	fmt.Stringer
}

type ActionRules struct {
	Executable        Filename
	WorkingDir        Directory
	Environment       internal_io.ProcessEnvironment
	Inputs            FileSet
	Outputs           FileSet
	Exports           FileSet
	Extras            FileSet
	Arguments         base.StringSet
	Dependencies      BuildAliases
	SourceControlPath Directory
	Options           OptionFlags
}

func (x *ActionRules) Alias() BuildAlias {
	capacity := 0
	for _, it := range x.Outputs {
		capacity += 1 + len(it.Dirname.Path) + 1 + len(it.Basename)
	}
	var bb BuildAliasBuilder
	MakeBuildAliasBuilder(&bb, "Action", capacity)
	for i, it := range x.Outputs {
		sep := ';'
		if i == 0 {
			sep = '/'
		}
		bb.WriteString(sep, it.Dirname.Path)
		bb.WriteString('/', it.Basename)
	}
	return bb.Alias()
}
func (x *ActionRules) Build(bc BuildContext) error {
	// track inputs that are generated by another action
	if err := bc.NeedFiles(x.Inputs...); err != nil {
		return err
	}

	// consolidate output files
	outputFiles := MergeFileSets(x.Outputs, x.Exports, x.Extras)
	outputFiles.Sort()

	// check if we can read action cache
	var cacheKey ActionCacheKey
	wasRetrievedFromCache := false

	flags := GetActionFlags()
	if x.Options.Has(OPT_ALLOW_CACHEREAD) && flags.CacheMode.HasRead() {
		var err error
		if cacheKey, err = GetActionCache().CacheRead(x, outputFiles); err == nil {
			wasRetrievedFromCache = true // cache-hit
			bc.Annotate(`CACHE`)
		}
	}

	// run process if the cache missed
	if !wasRetrievedFromCache {
		var processOptions internal_io.ProcessOptions
		var readFiles FileSet

		// run the external process with action command-line and file access hooking
		processOptions.Init(
			// internal_io.OptionProcessNewProcessGroup, // do not catch parent's signals
			internal_io.OptionProcessEnvironment(x.Environment),
			internal_io.OptionProcessWorkingDir(x.WorkingDir),
			internal_io.OptionProcessCaptureOutputIf(flags.ShowOutput.Get()),
			internal_io.OptionProcessUseResponseFileIf(x.Options.Has(OPT_ALLOW_RESPONSEFILE) && flags.ResponseFile.Get()),
			internal_io.OptionProcessFileAccess(func(far internal_io.FileAccessRecord) error {
				ignoreFile := true

				// only file access read/execute: output files could mess with writable mapped system Dll on Windows :'(
				if far.Access.HasRead() && !(far.Access.HasWrite() || far.Access.HasExecute()) {
					ignoreFile = (x.Inputs.Contains(far.Path) || outputFiles.Contains(far.Path))
				}

				if !ignoreFile {
					readFiles.AppendUniq(far.Path)
				}

				if flags.ShowFiles.Get() || base.IsLogLevelActive(base.LOG_VERYVERBOSE) {
					base.LogForwardf("%v: [%s]  %s%s", base.MakeStringer(func() string {
						return x.Alias().String()
					}), far.Access, far.Path, base.Blend("", " (IGNORED)", ignoreFile))
				}

				return nil
			}))

		// check action and environment parameters allow for distribution
		wasDistributed := false
		if x.Options.Has(OPT_ALLOW_DISTRIBUTION) && flags.DistMode.Enabled() {

			// check if process can be distributed in remote worker cluster
			if actionDist := GetActionDist(); actionDist.CanDistribute(flags.DistMode.Forced()) {
				peer, err := actionDist.DistributeAction(x.Alias(), x.Executable, x.Arguments, &processOptions)

				if wasDistributed = (peer != nil); wasDistributed {
					bc.Annotate(peer.GetAddress())
					if err != nil {
						return err
					}
				}
			}
		}

		// run process locally if it was not distributed
		if !wasDistributed {

			// limit number of concurrent external processes with MakeGlobalWorkerFuture()
			future := base.MakeGlobalWorkerFuture(func(tc base.ThreadContext) (int, error) {
				bc.Annotate(fmt.Sprintf("Thread:%d/%d", tc.GetThreadId()+1, tc.GetThreadPool().GetArity()))

				// base.LogClaim(LogAction, "[%02d] %s", tc.GetThreadId()+1, x.Outputs[0])
				internal_io.OptionProcessOnSpinnerMessage(func(executable Filename, arguments base.StringSet, options *internal_io.ProcessOptions) base.ProgressScope {
					spinner := base.LogSpinnerEx(
						base.ProgressOptionFormat("[W:%02d/%2d] %v",
							tc.GetThreadId()+1,
							tc.GetThreadPool().GetArity(),
							ForceLocalFilename(x.Outputs[0])),
						base.ProgressOptionColor(base.NewPastelizerColor(float64(tc.GetThreadId())/float64(tc.GetThreadPool().GetArity())).Quantize(true)))
					return spinner
				})(&processOptions)

				// check if we should log executed command-line
				if flags.ShowCmds.Get() {
					base.LogForwardln("\"", x.Executable.String(), "\" \"", strings.Join(x.Arguments, "\" \""), "\"")
				}

				return 0, internal_io.RunProcess(x.Executable, x.Arguments, internal_io.OptionProcessStruct(&processOptions))
			})

			if err := future.Join().Failure(); err != nil {
				return err
			}
		}

		if err := bc.NeedFiles(readFiles...); err != nil {
			return err
		}

		// whole input files set = static + dynamic
		actualInputs := MergeFileSets(x.Inputs, readFiles)

		// disable caching when inputs have unversioned modifications
		shouldWriteToCache := x.Options.Has(OPT_ALLOW_CACHEWRITE) && flags.CacheMode.HasWrite()
		if shouldWriteToCache && x.SourceControlPath.Valid() {
			if scm, err := BuildSourceControlModifiedFiles(x.SourceControlPath).Need(bc); err == nil {
				if modified := scm.GetUnversionedModificationsIndex(actualInputs...); modified < len(actualInputs) {
					shouldWriteToCache = false
					base.LogWarning(LogAction, "%v: excluded from cache since %q is locally modified", x.Alias(), actualInputs[modified])
				}
			} else {
				return err
			}
		}

		// check if this action results should be stored in cache
		if shouldWriteToCache {
			actionToWrite := x
			bc.OnBuilt(func(node BuildNode) error {
				// queue a new asynchronous task to avoid blocking the buildgraph
				base.AssertErr(func() error {
					if actionAlias := actionToWrite.Alias(); node.Alias() != actionAlias {
						return fmt.Errorf("action cache mismatching alias: %q vs %q", node.Alias(), actionAlias)
					}
					if actionNode := node.GetBuildable(); actionNode != actionToWrite {
						return fmt.Errorf("action cache mismatching buildable: %q vs %q", actionNode, actionToWrite)
					}
					return nil
				})
				base.AssertErr(func() error {
					action := node.GetBuildable().(*ActionRules)
					debugCacheKey := GetActionCache().(*actionCache).makeActionKey(action)
					if debugCacheKey == cacheKey {
						return nil
					}
					return fmt.Errorf("mismatching async cache write key: %q != %q", cacheKey, debugCacheKey)
				})
				return GetActionCache().AsyncCacheWrite(node, cacheKey, outputFiles, actualInputs)
			})
		} else if flags.CacheMode.HasWrite() && !wasRetrievedFromCache {
			base.LogVeryVerbose(LogActionCache, "skipped cache write for %q (opts=%v)", x.Alias(), x.Options)
		}
	}

	// check that process did write expected files and track them as outputs
	return bc.OutputFile(outputFiles...)
}

func (x *ActionRules) GetAction() *ActionRules { return x }
func (x *ActionRules) DependsOn(actions ...Action) {
	for _, other := range actions {
		x.Dependencies.AppendUniq(other.Alias())
	}
}
func (x *ActionRules) Serialize(ar base.Archive) {
	ar.Serializable(&x.Executable)
	ar.Serializable(&x.WorkingDir)
	ar.Serializable(&x.SourceControlPath)
	ar.Serializable(&x.Options)

	ar.Serializable(&x.Environment)

	ar.Serializable(&x.Inputs)
	ar.Serializable(&x.Arguments)

	ar.Serializable(&x.Outputs)
	ar.Serializable(&x.Exports)
	ar.Serializable(&x.Extras)

	base.SerializeSlice(ar, x.Dependencies.Ref())
}
func (x *ActionRules) String() string {
	oss := strings.Builder{}
	fmt.Fprintf(&oss, "%q", x.Executable)
	for _, arg := range x.Arguments {
		fmt.Fprintf(&oss, " %q", arg)
	}
	return oss.String()
}

/***************************************
 * Action Set
 ***************************************/

type ActionSet []Action

func (x ActionSet) Slice() []Action { return x }
func (x ActionSet) Aliases() BuildAliases {
	return MakeBuildAliases(x.Slice()...)
}
func (x ActionSet) Contains(action Action) bool {
	for _, it := range x {
		if it == action {
			return true
		}
	}
	return false
}
func (x *ActionSet) Append(actions ...Action) {
	base.Assert(func() bool {
		for _, it := range actions {
			action := it.GetAction()
			base.AssertErr(func() error {
				if len(action.Inputs) > 0 {
					return nil
				}
				return fmt.Errorf("%v: action without input", action.Alias())
			})
			base.AssertErr(func() error {
				if len(action.Outputs) > 0 {
					return nil
				}
				return fmt.Errorf("%v: action without output", action.Alias())
			})
		}
		return true
	})

	*x = base.AppendComparable_CheckUniq(*x, actions...)
}
func (x *ActionSet) DependsOn(actions ...Action) {
	if len(actions) == 0 {
		return
	}
	for _, action := range *x {
		action.DependsOn(actions...)
	}
}
func (x ActionSet) ExpandDependencies(result *ActionSet) error {
	for _, action := range x {
		if !result.Contains(action) {
			if actions, err := GetBuildActions(action.GetAction().Dependencies); err == nil {
				if err := actions.ExpandDependencies(result); err == nil {
					result.Append(action)
				} else {
					return err
				}
			} else {
				return err
			}
		}
	}
	return nil
}
func (x ActionSet) GetOutputFiles() (result FileSet) {
	for _, action := range x {
		result.Append(action.GetAction().Outputs...)
	}
	return result
}
func (x ActionSet) GetExportFiles() (result FileSet) {
	for _, action := range x {
		result.Append(action.GetAction().Exports...)
	}
	return result
}

func GetBuildActions(aliases BuildAliases) (ActionSet, error) {
	base.Assert(aliases.IsUniq)
	result := make(ActionSet, len(aliases))
	for i, alias := range aliases {
		if action, err := FindGlobalBuildable[Action](alias); err == nil {
			base.Assert(func() bool { return nil != action })
			result[i] = action
		} else {
			return ActionSet{}, err
		}
	}
	return result, nil
}

/***************************************
 * Action Options
 ***************************************/

type OptionType int32
type OptionFlags = base.EnumSet[OptionType, *OptionType]

const (
	OPT_ALLOW_CACHEREAD OptionType = iota
	OPT_ALLOW_CACHEWRITE
	OPT_ALLOW_DISTRIBUTION
	OPT_ALLOW_RESPONSEFILE

	OPT_ALLOW_CACHEREADWRITE OptionType = OPT_ALLOW_CACHEREAD | OPT_ALLOW_CACHEWRITE
)

func OptionTypes() []OptionType {
	return []OptionType{
		OPT_ALLOW_CACHEREAD,
		OPT_ALLOW_CACHEWRITE,
		OPT_ALLOW_DISTRIBUTION,
		OPT_ALLOW_RESPONSEFILE,
	}
}
func (x OptionType) Ord() int32           { return int32(x) }
func (x *OptionType) FromOrd(value int32) { *x = OptionType(value) }
func (x OptionType) String() string {
	switch x {
	case OPT_ALLOW_CACHEREAD:
		return "ALLOW_CACHEREAD"
	case OPT_ALLOW_CACHEWRITE:
		return "ALLOW_CACHEWRITE"
	case OPT_ALLOW_DISTRIBUTION:
		return "ALLOW_DISTRIBUTION"
	case OPT_ALLOW_RESPONSEFILE:
		return "ALLOW_RESPONSEFILE"
	default:
		base.UnexpectedValue(x)
		return ""
	}
}
func (x *OptionType) Set(in string) (err error) {
	switch strings.ToUpper(in) {
	case OPT_ALLOW_CACHEREAD.String():
		*x = OPT_ALLOW_CACHEREAD
	case OPT_ALLOW_CACHEWRITE.String():
		*x = OPT_ALLOW_CACHEWRITE
	case OPT_ALLOW_DISTRIBUTION.String():
		*x = OPT_ALLOW_DISTRIBUTION
	case OPT_ALLOW_RESPONSEFILE.String():
		*x = OPT_ALLOW_RESPONSEFILE
	default:
		err = base.MakeUnexpectedValueError(x, in)
	}
	return err
}
func (x *OptionType) Serialize(ar base.Archive) {
	ar.Int32((*int32)(x))
}
func (x OptionType) MarshalText() ([]byte, error) {
	return base.UnsafeBytesFromString(x.String()), nil
}
func (x *OptionType) UnmarshalText(data []byte) error {
	return x.Set(base.UnsafeStringFromBytes(data))
}
