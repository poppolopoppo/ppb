package cmd

import (
	"fmt"
	"io"
	"sort"

	"github.com/poppolopoppo/ppb/compile"
	"github.com/poppolopoppo/ppb/internal/base"
	internal_io "github.com/poppolopoppo/ppb/internal/io"
	"github.com/poppolopoppo/ppb/utils"
)

const BFF_VERSION = "0.8"

type BffArgs struct {
	BffOutput           utils.Filename
	DeoptimizeWithToken utils.BoolVar
	LightCache          utils.BoolVar
	Minify              utils.BoolVar
	RelativePaths       utils.BoolVar
	Clean               utils.BoolVar
}

func (x *BffArgs) Flags(cfv utils.CommandFlagsVisitor) {
	x.BffOutput = utils.UFS.Output.File(internal_io.BFF_DEFAULT_BASENAME)

	cfv.Persistent("BffOutput", "destination for generated FASTBuild config file (*.bff)", &x.BffOutput)
	cfv.Persistent("DeoptimizeWithToken", "enable/disable compiler optimization with FASTBUILD_DEOPTIMIZE_OBJECT", &x.DeoptimizeWithToken)
	cfv.Persistent("LightCache", "enable/disable FASTBuild lightweight parsing for caching", &x.LightCache)
	cfv.Persistent("Minify", "enable/disable pretty print for generated FASTBuild file", &x.Minify)
	cfv.Persistent("RelativePaths", "enable/disable FASTBuild relative paths for caching", &x.RelativePaths)
	cfv.Variable("Clean", "invalidate and regenerate BFF file", &x.Clean)
}

var GetBffArgs = utils.NewCommandParsableFlags(&BffArgs{
	BffOutput:           utils.UFS.Output.File(internal_io.BFF_DEFAULT_BASENAME),
	DeoptimizeWithToken: base.INHERITABLE_FALSE,
	LightCache:          base.INHERITABLE_FALSE,
	Minify:              base.INHERITABLE_TRUE,
	RelativePaths:       base.INHERITABLE_FALSE,
	Clean:               base.INHERITABLE_FALSE,
})

var CommandBff = utils.NewCommand(
	"Configure",
	"bff",
	"generate FASTBuild config file",
	utils.OptionCommandParsableAccessor("BFF", "bff generation options", GetBffArgs),
	compile.OptionCommandAllCompilationFlags(),
	utils.OptionCommandPrepare(func(cc utils.CommandContext) error {
		// prepare source control early on, without blocking
		utils.BuildSourceControlModifiedFiles(utils.UFS.Source).Prepare(utils.CommandEnv.BuildGraph())
		return nil
	}),
	utils.OptionCommandRun(func(cc utils.CommandContext) error {
		base.LogClaim(utils.LogCommand, "generating BFF config in '%v'", GetBffArgs().BffOutput)

		return GetBffBuilder().Build(utils.CommandEnv.BuildGraph()).Failure()
	}))

func GetBffBuilder() utils.BuildFactoryTyped[*BffBuilder] {
	return utils.MakeBuildFactory(func(bi utils.BuildInitializer) (BffBuilder, error) {
		flags := GetBffArgs()
		return BffBuilder{
			Output:  flags.BffOutput,
			Version: BFF_VERSION,
		}, bi.NeedFactories(utils.GetBuildableFlags(flags))
	})
}

/***************************************
 * FASTBuild config generation
 ***************************************/

type BffBuilder struct {
	Output  utils.Filename
	Version string
}

func (x *BffBuilder) Alias() utils.BuildAlias {
	return utils.MakeBuildAlias("Bff", x.Output.String())
}
func (x *BffBuilder) Serialize(ar base.Archive) {
	ar.Serializable(&x.Output)
	ar.String(&x.Version)
}
func (x *BffBuilder) Build(bc utils.BuildContext) (err error) {
	sourceControlModifiedFiles, err := utils.BuildSourceControlModifiedFiles(utils.UFS.Source).Need(bc)
	if err != nil {
		return nil
	}

	args := GetBffArgs()

	err = utils.UFS.SafeCreate(x.Output, func(dst io.Writer) error {

		bff := newBffGenerator(dst, args)

		bff.Comment("BFF generated by %v", utils.PROCESS_INFO)
		bff.Func("Settings", func() {
			bff.Assign("RootPath", utils.UFS.Root)
			bff.Assign("CachePath", utils.UFS.Cache)

			if base.CurrentHost().Id == base.HOST_WINDOWS {
				platform := compile.GeLocalHostBuildPlatform().SafeNeed(bc)
				compiler := platform.GetCompiler().SafeNeed(bc)

				bff.Assign("Environment", compiler.GetCompiler().Environment.Export())
			}
		})

		sourceControlModifiedFilesOutputFile := utils.UFS.Saved.File(".modified_files_list.txt")
		if err := utils.UFS.CreateBuffered(sourceControlModifiedFilesOutputFile, func(w io.Writer) error {
			for _, file := range sourceControlModifiedFiles.ModifiedFiles {
				if _, err := fmt.Fprintln(w, file.String()); err != nil {
					return err
				}
			}
			return nil
		}); err != nil {
			return err
		}

		bff.Comment("Global invariants")
		bff.Assign("CompilerOutputKeepBaseExtension", false)
		bff.Assign("DeoptimizeWritableFilesWithToken", args.DeoptimizeWithToken)
		bff.Assign("LinkerVerboseOutput", true)
		bff.Assign("UnityInputIsolateListFile", sourceControlModifiedFilesOutputFile)

		translatedUnits, err := compile.NeedAllBuildUnits(bc)
		if err != nil {
			return err
		}

		for _, unit := range translatedUnits {
			bff.Comment("Target %v", unit.TargetAlias)
			switch unit.Payload {
			case compile.PAYLOAD_EXECUTABLE:
				bff.Executable(unit)
			case compile.PAYLOAD_HEADERS:
				bff.Headers(unit)
			case compile.PAYLOAD_OBJECTLIST:
				bff.ObjectList(unit)
			case compile.PAYLOAD_SHAREDLIB:
				bff.SharedLib(unit)
			case compile.PAYLOAD_STATICLIB:
				bff.StaticLib(unit)
			default:
				base.UnexpectedValuePanic(unit.Payload, unit.Payload)
			}
		}

		bff.MakeAliases(translatedUnits)
		return nil
	})

	if err == nil {
		err = bc.OutputFile(x.Output)
	}
	return
}

type bffGenerator struct {
	*BffArgs
	*internal_io.BffFile
}

func newBffGenerator(dst io.Writer, args *BffArgs) (result bffGenerator) {
	result = bffGenerator{
		BffArgs: args,
		BffFile: internal_io.NewBffFile(dst, args.Minify.Get()),
	}
	return result
}

func (gen bffGenerator) Executable(unit *compile.Unit) error {
	return gen.BaseDeliverable(unit, true)
}
func (gen bffGenerator) Headers(unit *compile.Unit) error {
	gen.Func("Alias", func() {
		fileset := utils.FileSet{}
		fileset.Append(unit.Source.ExtraFiles...)
		fileset.Append(unit.Libraries...)
		gen.Assign("Targets", fileset)
	}, unit.TargetAlias.String())
	return nil
}
func (gen bffGenerator) ObjectList(unit *compile.Unit) error {
	compiler, preprocessor, err := gen.Toolchain(unit)
	if err != nil {
		return err
	}
	gen.BaseModule(unit, compiler, preprocessor, "", true)
	return nil
}
func (gen bffGenerator) SharedLib(unit *compile.Unit) error {
	return gen.BaseDeliverable(unit, false)
}
func (gen bffGenerator) StaticLib(unit *compile.Unit) error {
	compiler, preprocessor, err := gen.Toolchain(unit)
	if err != nil {
		return err
	}

	gen.BaseModule(unit, compiler, preprocessor, "", false)
	return nil
}
func (gen bffGenerator) Toolchain(unit *compile.Unit) (internal_io.BffVar, internal_io.BffVar, error) {
	compiler, err := unit.GetBuildCompiler()
	if err != nil {
		var none internal_io.BffVar
		return none, none, err
	}

	compilerDetails := gen.Compiler(compiler)

	var preprocessorDetails internal_io.BffVar
	if unit.PreprocessorAlias.Valid() {
		preprocessor, err := unit.GetBuildPreprocessor()
		if err != nil {
			var none internal_io.BffVar
			return none, none, err
		}

		preprocessorDetails = gen.Compiler(preprocessor)
	}

	return compilerDetails, preprocessorDetails, nil
}
func (gen bffGenerator) BaseDeliverable(unit *compile.Unit, executable bool) error {
	compiler, preprocessor, err := gen.Toolchain(unit)
	if err != nil {
		return err
	}

	libraries := []string{gen.BaseModule(unit, compiler, preprocessor, "-Obj", true)}
	libraries = append(libraries, base.Stringize(unit.CompileDependencies.Slice()...)...)
	libraries = append(libraries, base.Stringize(unit.LinkDependencies.Slice()...)...)
	libraries = append(libraries, gen.CustomUnits(unit)...)

	funcName := "DLL"
	if executable {
		funcName = "Executable"
	}

	gen.Func(funcName, func() {
		gen.Using(compiler)
		gen.Assign("Libraries", internal_io.MakeBffArray(libraries...))
		gen.Assign("LinkerOptions", unit.LinkerOptions.Join(" "))
		gen.Assign("LinkerOutput", unit.OutputFile)
		gen.Assign("PreBuildDependencies", base.Stringize(unit.RuntimeDependencies.Slice()...))
	}, unit.TargetAlias.String())
	return nil
}
func (gen bffGenerator) BaseModule(unit *compile.Unit, compiler, preprocessor internal_io.BffVar, suffix string, linkLibraryObjects bool) string {
	utils.UFS.Mkdir(utils.UFS.Transient)

	moduleSource := internal_io.MakeBffVar(unit.TargetAlias.ModuleAlias.String() + "_Source_" + unit.PCH.String() + "_" + unit.Unity.String())
	gen.Once(moduleSource, func() {
		gen.Comment("Target source details for %v", unit)

		var moduleUnity string
		if unit.Unity.Ord() > 0 {
			moduleUnity = unit.TargetAlias.ModuleAlias.String() + "-Unity-PCH_" + unit.PCH.String()

			gen.Once(internal_io.BffVar(moduleUnity), func() {
				gen.Func("Unity", func() {
					gen.Assign("Hidden", true)
					gen.Assign("UnityNumFiles", unit.Unity.Ord())
					gen.Assign("UnityInputFiles", unit.Source.SourceFiles)
					gen.Assign("UnityInputPath", unit.Source.SourceDirs)
					gen.Assign("UnityInputPattern", unit.Source.SourceGlobs)
					gen.Assign("UnityInputExcludedFiles", unit.Source.ExcludedFiles)
					gen.Assign("UnityInputExcludePattern", unit.Source.ExcludedGlobs)
					gen.Assign("UnityInputIsolatedFiles", unit.Source.IsolatedFiles)
					gen.Assign("UnityOutputPath", unit.GeneratedDir)
					gen.Assign("UnityOutputPattern", fmt.Sprintf("%s_*_of_%d.cpp", unit.TargetAlias.ModuleName, unit.Unity.Ord()))
					if unit.PCH != compile.PCH_DISABLED {
						gen.Assign("UnityPCH", unit.PrecompiledHeader.Basename)
					}
				}, moduleUnity)
			})
		}

		gen.Struct(moduleSource, func() {
			gen.Assign("CompilerInputFilesRoot", unit.ModuleDir)
			if moduleUnity != "" {
				gen.Assign("CompilerInputUnity", moduleUnity)
			} else {
				gen.Assign("CompilerInputFiles", unit.Source.SourceFiles)
				if unit.Source.SourceDirs.Len() > 0 {
					gen.Assign("CompilerInputPattern", unit.Source.SourceGlobs)
					gen.Assign("CompilerInputPath", unit.Source.SourceDirs)
					gen.Assign("CompilerInputPathRecurse", true)
				}
				gen.Assign("CompilerInputExcludedFiles", unit.Source.ExcludedFiles)
				gen.Assign("CompilerInputExcludePattern", unit.Source.ExcludedGlobs)
			}
			if unit.PCH == compile.PCH_MONOLITHIC {
				gen.Assign("PCHInputFile", unit.PrecompiledSource)
			}
		})
	})

	artifactId := (unit.TargetAlias.String() + suffix)

	funcName := "Library"
	if linkLibraryObjects {
		funcName = "ObjectList"
	}

	gen.Func(funcName, func() {
		gen.Using(compiler)
		gen.Using(moduleSource)

		if suffix != "" {
			gen.Assign("Hidden", true)
		}

		gen.Assign("CompilerOutputPath", unit.IntermediateDir)
		gen.Assign("CompilerOptions", unit.CompilerOptions.Join(" "))

		if unit.PCH == compile.PCH_MONOLITHIC {
			gen.Assign("PCHOutputFile", unit.PrecompiledObject)
			gen.Assign("PCHOptions", unit.PrecompiledHeaderOptions.Join(" "))
		}

		if preprocessor.Valid() {
			gen.Assign("Preprocessor", preprocessor)
			gen.Assign("PreprocessorOptions", unit.PreprocessorOptions.Join(" "))
		}

		if !linkLibraryObjects {
			compileDepAliases := base.Stringize(unit.CompileDependencies.Slice()...)
			compileDepAliases = append(compileDepAliases, gen.CustomUnits(unit)...)

			gen.Assign("LibrarianAdditionalInputs", compileDepAliases)
			gen.Assign("LibrarianOptions", unit.LibrarianOptions.Join(" "))
			gen.Assign("LibrarianOutput", unit.OutputFile)
		}

		includeDepAliases := base.Stringize(unit.IncludeDependencies.Slice()...)
		gen.Assign("PreBuildDependencies", includeDepAliases)

	}, artifactId)

	return artifactId
}
func (gen bffGenerator) Compiler(compiler compile.Compiler) internal_io.BffVar {
	rules := compiler.GetCompiler()
	compilerName := rules.CompilerAlias.String()
	details := internal_io.MakeBffVar(compilerName + "_Details")

	gen.Once(details, func() {
		gen.Func("Compiler", func() {
			gen.Assign("CompilerFamily", rules.CompilerAlias.CompilerFamily)
			gen.Assign("Executable", rules.Executable)
			gen.Assign("ExtraFiles", rules.ExtraFiles)
			gen.Assign("ExecutableRootPath", rules.Executable.Dirname)
			gen.Assign("Environment", rules.Environment.Export())
			gen.Assign("AllowDistribution", rules.Features.Has(compile.COMPILER_ALLOW_DISTRIBUTION))
			gen.Assign("AllowResponseFile", rules.Features.Has(compile.COMPILER_ALLOW_RESPONSEFILE))
			// gen.Assign("SourceMapping_Experimental", rules.Features.Has(COMPILER_ALLOW_SOURCEMAPPING))
			gen.Assign("UseLightCache_Experimental", gen.LightCache)
			gen.Assign("UseRelativePaths_Experimental", gen.RelativePaths)
		}, compilerName)
		gen.Struct(details, func() {
			gen.Assign("Compiler", compilerName)
			gen.Assign("Librarian", rules.Librarian)
			gen.Assign("Linker", rules.Linker)
		})
	})
	return details
}
func (gen bffGenerator) CustomUnits(unit *compile.Unit) []string {
	return base.Map(func(custom compile.CustomUnit) string {
		compiler, preprocessor, err := gen.Toolchain(&custom.Unit)
		base.LogPanicIfFailed(utils.LogCommand, err)

		return gen.BaseModule(&custom.Unit, compiler, preprocessor, "", true)
	}, unit.CustomUnits...)
}
func (gen bffGenerator) MakeAliases(units []*compile.Unit) {
	environments := make(map[string]base.StringSet)
	namespaces := make(map[string]base.StringSet)
	modules := make(map[string]base.StringSet)

	registerAlias := func(m map[string]base.StringSet, k, v string) {
		m[k] = append(m[k], v)
	}

	for _, u := range units {
		target := u.TargetAlias
		alias := target.String()

		registerAlias(environments, target.EnvironmentAlias.String(), alias)
		registerAlias(namespaces, target.NamespaceAlias.String(), alias)
		registerAlias(modules, target.ModuleAlias.String(), alias)
	}

	for _, registry := range []map[string]base.StringSet{environments, namespaces, modules} {
		sortedKeys := base.Keys(registry)
		sort.Strings(sortedKeys)

		for _, alias := range sortedKeys {
			list := registry[alias]
			sort.Strings(list)
			gen.Func("Alias", func() {
				gen.Assign("Targets", list)
			}, alias)
		}
	}

	gen.Func("Alias", func() {
		names := base.Keys(environments)
		sort.Strings(names)
		gen.Assign("Targets", names)
	}, "all")
}
