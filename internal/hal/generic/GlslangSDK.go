package generic

import (
	"io"

	"github.com/poppolopoppo/ppb/compile"
	"github.com/poppolopoppo/ppb/internal/base"
	internal_io "github.com/poppolopoppo/ppb/internal/io"
	. "github.com/poppolopoppo/ppb/utils"
)

var Glslang = compile.RegisterArchetype("SDK/GLSLANG", func(rules *compile.ModuleRules) error {
	rules.Generate(compile.PUBLIC, "glslang-headers.generated.h", &GlslangHeaderGenerator{
		Version: GlslangHeaderVersion,
	})
	return nil
})

/***************************************
 * Glslang header generator
 ***************************************/

var GlslangHeaderVersion = "GlslangGeneratedHeader-1.0.0"

type GlslangHeaderGenerator struct {
	Version string
}

func (x *GlslangHeaderGenerator) Serialize(ar Archive) {
	ar.String(&x.Version)
}
func (x GlslangHeaderGenerator) CreateGenerated(unit *compile.Unit, output Filename) (compile.Generated, error) {
	var extractDir Directory
	if input, err := unit.Exports.Get("Glslang/Path"); err == nil {
		extractDir = unit.ModuleDir.AbsoluteFolder(input)
	} else {
		return nil, err
	}

	result := &GlslangGeneratedHeader{
		Version:     x.Version,
		ExtractDir:  extractDir,
		UseDebugSDK: unit.Tagged(compile.TAG_DEBUG),
	}
	if overrideDir := unit.Exports.GetOrElse("Glslang/Override", ""); len(overrideDir) > 0 {
		result.OverrideDir = MakeDirectory(overrideDir)
	}
	return result, nil
}

type GlslangGeneratedHeader struct {
	Version     string
	ExtractDir  Directory
	OverrideDir Directory
	UseDebugSDK bool
}

func (x *GlslangGeneratedHeader) Serialize(ar Archive) {
	ar.String(&x.Version)
	ar.Serializable(&x.ExtractDir)
	ar.Serializable(&x.OverrideDir)
	ar.Bool(&x.UseDebugSDK)
}
func (x *GlslangGeneratedHeader) Generate(bc BuildContext, generated *compile.BuildGenerated, dst io.Writer) error {
	includeRe := MakeGlobRegexp(glslangGlobIncludes...)
	librariesRe := MakeGlobRegexp(glslangGlobLibraries...)

	var sdkDir Directory
	var sdkFiles FileSet
	if x.OverrideDir.Valid() {
		sdkDir = x.OverrideDir

		var err error
		if sdkFiles, err = internal_io.ListDirectory(bc, sdkDir); err != nil {
			return err
		}
	} else {
		config := getGlslangConfig(x.UseDebugSDK)

		if downloader, err := getGlslangDownloader(config).Need(bc); err == nil {
			if ar, err := getGlslangExtractor(downloader, x.ExtractDir.Folder(config)).Need(bc); err == nil {
				sdkDir = ar.Destination
				sdkFiles = ar.ExtractedFiles
			} else {
				return err
			}
		} else {
			return err
		}
	}

	var sdkHeaders, sdkLibraries FileSet
	for _, it := range sdkFiles {
		rel := it.Relative(sdkDir)
		if includeRe.MatchString(rel) {
			sdkHeaders.Append(it)
		} else if librariesRe.MatchString(rel) {
			sdkLibraries.Append(it)
		}
	}

	cpp := internal_io.NewCppFile(dst, false)
	cpp.Comment("Glslang header generated by %v -- glslang v%v", CommandEnv.Prefix(), x.Version)
	cpp.Pragma("once")

	includeDir := sdkDir.Folder("include")

	for _, it := range sdkHeaders {
		cpp.Pragma("include_alias(\"%v\", \"%v\")",
			SanitizePath(it.Relative(includeDir), '/'),
			SanitizePath(it.Relative(UFS.Source), '/'))
	}

	for _, it := range sdkLibraries {
		cpp.Pragma("comment(lib, %q)", it)
	}

	return nil
}

/***************************************
 * Download Glslang SDK release from Github
 ***************************************/

var glslangGlobIncludes = base.StringSet{
	"include/glslang/Include/*",
	"include/glslang/Public/*",
	"include/glslang/MachineIndependent/*",
	"include/glslang/SPIRV/*",
}
var glslangGlobLibraries = base.StringSet{
	"lib/GenericCodeGen*",
	"lib/glslang*",
	"lib/MachineIndependent*",
	"lib/OGLCompiler*",
	"lib/OSDependent*",
	"lib/SPIRV*",
}

func getGlslangExtractor(download *internal_io.Downloader, extractDir Directory) BuildFactoryTyped[*internal_io.CompressedUnarchiver] {
	return internal_io.BuildCompressedArchiveExtractorFromDownload(
		internal_io.CompressedArchiveFromDownload{
			Download:   download,
			ExtractDir: extractDir,
		},
		MakeGlobRegexp(glslangGlobIncludes.Concat(glslangGlobLibraries)...))
}

func getGlslangConfig(debug bool) string {
	var config string
	switch GetCurrentHost().Id {
	case base.HOST_WINDOWS:
		config = "windows-x64"
	case base.HOST_LINUX:
		config = "linux"
	case base.HOST_DARWIN:
		config = "osx"
	default:
		base.NotImplemented("glslang: no support available for platform '%s'", GetCurrentHost().Id)
	}
	if debug {
		config += "-Debug"
	} else {
		config += "-Release"
	}
	return config
}

func getGlslangDownloader(config string) BuildFactoryTyped[*internal_io.Downloader] {
	return internal_io.BuildDownloaderFromUrl(
		"http://github.com/KhronosGroup/glslang/releases/download/master-tot/glslang-master-"+config+".zip",
		UFS.Transient.Folder("SDK"),
		internal_io.DOWNLOAD_DEFAULT)
}
