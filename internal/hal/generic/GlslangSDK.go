package generic

import (
	"io"

	"github.com/poppolopoppo/ppb/compile"
	"github.com/poppolopoppo/ppb/internal/base"
	internal_io "github.com/poppolopoppo/ppb/internal/io"
	. "github.com/poppolopoppo/ppb/utils"
)

var Glslang = compile.RegisterArchetype("SDK/GLSLANG", func(rules *compile.ModuleRules) error {
	rules.Generate(compile.PUBLIC, "glslang-headers.generated.h", &GlslangHeaderGenerator{
		Version: GlslangHeaderVersion,
	})
	return nil
})

/***************************************
 * Glslang header generator
 ***************************************/

var GlslangHeaderVersion = "GlslangGeneratedHeader-1.0.0"

type GlslangHeaderGenerator struct {
	Version string
}

func (x *GlslangHeaderGenerator) Serialize(ar Archive) {
	ar.String(&x.Version)
}
func (x GlslangHeaderGenerator) CreateGenerated(unit *compile.Unit, output Filename) compile.Generated {
	return &GlslangGeneratedHeader{
		Version:     x.Version,
		ExtractDir:  unit.ModuleDir.AbsoluteFolder(unit.Exports.Get("Glslang/Path")),
		UseDebugSDK: !unit.Tagged(compile.TAG_NDEBUG),
	}
}

type GlslangGeneratedHeader struct {
	Version     string
	ExtractDir  Directory
	UseDebugSDK bool
}

func (x *GlslangGeneratedHeader) Serialize(ar Archive) {
	ar.String(&x.Version)
	ar.Serializable(&x.ExtractDir)
	ar.Bool(&x.UseDebugSDK)
}
func (x GlslangGeneratedHeader) Generate(bc BuildContext, generated *compile.BuildGenerated, dst io.Writer) error {
	config := getGlslangConfig(x.UseDebugSDK)
	downloader, err := getGlslangDownloader(config).Need(bc)
	if err != nil {
		return err
	}

	extractDir := x.ExtractDir.Folder(config)
	ar, err := getGlslangExtractor(downloader, extractDir).Need(bc)
	if err != nil {
		return err
	}

	cpp := internal_io.NewCppFile(dst, false)
	cpp.Comment("Glslang header generated by %v -- glslang v%v", CommandEnv.Prefix(), x.Version)
	cpp.Pragma("once")

	includeDir := ar.Destination.Folder("Include")
	includeRe := MakeGlobRegexp(glslangGlobIncludes...)

	for _, x := range ar.ExtractedFiles {
		rel := x.Relative(ar.Destination)
		if includeRe.MatchString(rel) {
			cpp.Pragma("include_alias(\"%v\", \"%v\")",
				SanitizePath(x.Relative(includeDir), '/'),
				SanitizePath(x.Relative(UFS.Source), '/'))
		}
	}

	librariesRe := MakeGlobRegexp(glslangGlobLibraries...)
	for _, it := range ar.ExtractedFiles {
		rel := it.Relative(ar.Destination)
		if librariesRe.MatchString(rel) {
			cpp.Pragma("comment(lib, %q)", it)
		}
	}

	return nil
}

/***************************************
 * Download Glslang SDK release from Github
 ***************************************/

var glslangGlobIncludes = base.StringSet{
	"include/glslang/Include/*",
	"include/glslang/Public/*",
	"include/glslang/MachineIndependent/*",
	"include/glslang/SPIRV/*",
}
var glslangGlobLibraries = base.StringSet{
	"lib/GenericCodeGen*",
	"lib/glslang*",
	"lib/MachineIndependent*",
	"lib/OGLCompiler*",
	"lib/OSDependent*",
	"lib/SPIRV*",
}

func getGlslangExtractor(download *internal_io.Downloader, extractDir Directory) BuildFactoryTyped[*internal_io.CompressedUnarchiver] {
	return internal_io.BuildCompressedArchiveExtractorFromDownload(
		internal_io.CompressedArchiveFromDownload{
			Download:   download,
			ExtractDir: extractDir,
		},
		glslangGlobIncludes.Concat(glslangGlobLibraries))
}

func getGlslangConfig(debug bool) string {
	var config string
	switch CurrentHost().Id {
	case base.HOST_WINDOWS:
		config = "windows-x64"
	case base.HOST_LINUX:
		config = "linux"
	case base.HOST_DARWIN:
		config = "osx"
	default:
		base.NotImplemented("glslang: no support available for platform '%s'", CurrentHost().Id)
	}
	if debug {
		config += "-Debug"
	} else {
		config += "-Release"
	}
	return config
}

func getGlslangDownloader(config string) BuildFactoryTyped[*internal_io.Downloader] {
	return internal_io.BuildDownloader(
		"http://github.com/KhronosGroup/glslang/releases/download/master-tot/glslang-master-"+config+".zip",
		UFS.Transient.Folder("SDK").File("glslang-master-"+config+".zip"),
		internal_io.DOWNLOAD_DEFAULT)
}
