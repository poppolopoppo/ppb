package generic

import (
	"io"

	. "github.com/poppolopoppo/ppb/compile"
	. "github.com/poppolopoppo/ppb/internal/io"
	. "github.com/poppolopoppo/ppb/utils"
)

var Glslang = RegisterArchetype("SDK/GLSLANG", func(rules *ModuleRules) {
	rules.Generate(PUBLIC, "glslang-headers.generated.h", &GlslangHeaderGenerator{
		Version: GlslangHeaderVersion,
	})
})

/***************************************
 * Glslang header generator
 ***************************************/

var GlslangHeaderVersion = "GlslangGeneratedHeader-1.0.0"

type GlslangHeaderGenerator struct {
	Version string
}

func (x *GlslangHeaderGenerator) Serialize(ar Archive) {
	ar.String(&x.Version)
}
func (x GlslangHeaderGenerator) CreateGenerated(unit *Unit, output Filename) Generated {
	return &GlslangGeneratedHeader{
		Version:     x.Version,
		ExtractDir:  unit.ModuleDir.AbsoluteFolder(unit.Exports.Get("Glslang/Path")),
		UseDebugSDK: !unit.Tagged(TAG_NDEBUG),
	}
}

type GlslangGeneratedHeader struct {
	Version     string
	ExtractDir  Directory
	UseDebugSDK bool
}

func (x *GlslangGeneratedHeader) Serialize(ar Archive) {
	ar.String(&x.Version)
	ar.Serializable(&x.ExtractDir)
	ar.Bool(&x.UseDebugSDK)
}
func (x GlslangGeneratedHeader) Generate(bc BuildContext, generated *BuildGenerated, dst io.Writer) error {
	config := getGlslangConfig(x.UseDebugSDK)
	downloader, err := getGlslangDownloader(config).Need(bc)
	if err != nil {
		return err
	}

	extractDir := x.ExtractDir.Folder(config)
	ar, err := getGlslangExtractor(downloader, extractDir).Need(bc)
	if err != nil {
		return err
	}

	cpp := NewCppFile(dst, false)
	cpp.Comment("Glslang header generated by %v -- glslang v%v", CommandEnv.Prefix(), x.Version)
	cpp.Pragma("once")

	includeDir := ar.Destination.Folder("Include")
	includeRe := MakeGlobRegexp(glslangGlobIncludes...)

	for _, x := range ar.ExtractedFiles {
		rel := x.Relative(ar.Destination)
		if includeRe.MatchString(rel) {
			cpp.Pragma("include_alias(\"%v\", \"%v\")",
				SanitizePath(x.Relative(includeDir), '/'),
				SanitizePath(x.Relative(UFS.Source), '/'))
		}
	}

	librariesRe := MakeGlobRegexp(glslangGlobLibraries...)
	for _, it := range ar.ExtractedFiles {
		rel := it.Relative(ar.Destination)
		if librariesRe.MatchString(rel) {
			cpp.Pragma("comment(lib, %q)", it)
		}
	}

	return nil
}

/***************************************
 * Download Glslang SDK release from Github
 ***************************************/

var glslangGlobIncludes = StringSet{
	"include/glslang/Include/*",
	"include/glslang/Public/*",
	"include/glslang/MachineIndependent/*",
	"include/glslang/SPIRV/*",
}
var glslangGlobLibraries = StringSet{
	"lib/GenericCodeGen*",
	"lib/glslang*",
	"lib/MachineIndependent*",
	"lib/OGLCompiler*",
	"lib/OSDependent*",
	"lib/SPIRV*",
}

func getGlslangExtractor(download *Downloader, extractDir Directory) BuildFactoryTyped[*CompressedUnarchiver] {
	return BuildCompressedArchiveExtractorFromDownload(
		CompressedArchiveFromDownload{
			Download:   download,
			ExtractDir: extractDir,
		},
		glslangGlobIncludes.Concat(glslangGlobLibraries))
}

func getGlslangConfig(debug bool) string {
	var config string
	switch CurrentHost().Id {
	case HOST_WINDOWS:
		config = "windows-x64"
	case HOST_LINUX:
		config = "linux"
	case HOST_DARWIN:
		config = "osx"
	default:
		NotImplemented("glslang: no support available for platform '%s'", CurrentHost().Id)
	}
	if debug {
		config += "-Debug"
	} else {
		config += "-Release"
	}
	return config
}

func getGlslangDownloader(config string) BuildFactoryTyped[*Downloader] {
	return BuildDownloader(
		"http://github.com/KhronosGroup/glslang/releases/download/master-tot/glslang-master-"+config+".zip",
		UFS.Transient.Folder("SDK").File("glslang-master-"+config+".zip"),
		DOWNLOAD_DEFAULT)
}
