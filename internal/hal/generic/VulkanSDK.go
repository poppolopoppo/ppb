package generic

import (
	"fmt"
	"io"
	"regexp"
	"sort"
	"strings"

	"github.com/poppolopoppo/ppb/compile"
	"github.com/poppolopoppo/ppb/internal/base"
	internal_io "github.com/poppolopoppo/ppb/internal/io"
	"github.com/poppolopoppo/ppb/utils"
)

var Vulkan = compile.RegisterArchetype("SDK/VULKAN", func(rules *compile.ModuleRules) error {
	rules.Generate(compile.PUBLIC, "vulkan-exports.generated.h", &VulkanHeaderGenerator{
		Version: VulkanHeaderVersion,
	})
	rules.Generate(compile.PRIVATE, "vulkan-exports.generated.cpp", &VulkanSourceGenerator{
		Version:         VulkanSourceVersion,
		GeneratedHeader: "vulkan-exports.generated.h",
	})
	return nil
})

func getVulkanBindingsFile(unit *compile.Unit) utils.Filename {
	return unit.ModuleDir.AbsoluteFile(unit.Exports.Get("Vulkan/Bindings"))
}
func getVulkanIncludeDir(unit *compile.Unit) utils.Directory {
	return unit.ModuleDir.AbsoluteFolder(unit.Exports.Get("Vulkan/Path"))
}

/***************************************
 * Vulkan generated header
 ***************************************/

var VulkanHeaderVersion = "VulkanGeneratedHeader-1.0.0"

type VulkanHeaderGenerator struct {
	Version string
}

func (x *VulkanHeaderGenerator) Serialize(ar base.Archive) {
	ar.String(&x.Version)
}
func (x VulkanHeaderGenerator) CreateGenerated(unit *compile.Unit, output utils.Filename) compile.Generated {
	return &VulkanGeneratedHeader{
		Version:      x.Version,
		BindingsFile: getVulkanBindingsFile(unit),
		IncludeDir:   getVulkanIncludeDir(unit),
	}
}

var re_vkIdentifier = regexp.MustCompile(`^\w+`)

type VulkanGeneratedHeader struct {
	Version      string
	BindingsFile utils.Filename
	IncludeDir   utils.Directory
}

func (x *VulkanGeneratedHeader) Serialize(ar base.Archive) {
	ar.String(&x.Version)
	ar.Serializable(&x.BindingsFile)
	ar.Serializable(&x.IncludeDir)
}
func (g VulkanGeneratedHeader) Generate(bc utils.BuildContext, generated *compile.BuildGenerated, dst io.Writer) error {
	vk, err := GetVulkanInterface(VulkanInterfaceParams{g.IncludeDir, g.BindingsFile}).Need(bc)
	if err != nil {
		return err
	}

	cpp := internal_io.NewCppFile(dst, false)
	cpp.Comment("Vulkan header generated by %v - vulkan v%v", utils.CommandEnv.Prefix(), VulkanHeaderVersion)
	cpp.Pragma("once")
	cpp.Include("Container/BitMask.h")
	for _, x := range vk.Headers {
		cpp.Include(utils.SanitizePath(x.Relative(utils.UFS.Source), '/'))
	}

	cpp.IfnDef("VKLOG_APICALL", func() {
		cpp.Define("VKLOG_APICALL(_NAME, ...)", "NOOP()")
	})

	makeExtensionEnumDecl := func(name string, exts []VkExtension) {
		cpp.Comment(name)
		cpp.EnumC99(name, "uint32_t", func() {
			cpp.Println(name + "_unknown = 0,")
			for _, x := range exts {
				cpp.IfDef(x.Name, func() {
					if len(x.Requires) > 0 {
						cpp.Println("%s, // requires: %v", getVkExtensionFlag(x.Name), x.Requires.Join(", "))
					} else {
						cpp.Println("%s,", getVkExtensionFlag(x.Name))
					}
				})
			}
			cpp.Println(name + "_count,")
		})

		cpp.Statement("using %s_set = PPE::TFixedSizeBitMask<static_cast<uint32_t>(%s_count)>", name, name)
		cpp.Func(name+"_name", "const char*", []string{name + " ext"}, "", nil)
		cpp.Func(name+"_from", name, []string{"const char* name"}, "", nil)
		cpp.Func(name+"s_available", name+"_set", []string{}, "", nil)
		cpp.Func(name+"s_require", name+"_set", []string{"const " + name + "_set& in"}, "", nil)
		cpp.Func("operator &", "CONSTEXPR bool", []string{"const " + name + "_set& bits", name + " ext"}, "", func() {
			cpp.Statement("return bits.Get(static_cast<size_t>(ext))")
		})
		cpp.Func("operator +=", "CONSTEXPR "+name+"_set&", []string{name + "_set& bits", name + " ext"}, "", func() {
			cpp.Statement("bits.SetTrue(static_cast<size_t>(ext)); return bits")
		})
		cpp.Func("operator -=", "CONSTEXPR "+name+"_set&", []string{name + "_set& bits", name + " ext"}, "", func() {
			cpp.Statement("bits.SetFalse(static_cast<size_t>(ext)); return bits")
		})
	}

	makePfnDecl := func(funcs []VkFunction) {
		n := len(funcs)
		for i, x := range funcs {
			cpp.LazyIfDef(x.Requires, func() {
				if x.VkFunctionPointer != nil {
					cpp.Statement("PFN_%s %s{ nullptr }", x.Name, x.Name)
				}
			}, i+1 == n)
		}
	}

	makePfnWrapper := func(ptr string, funcs []VkFunction) {
		n := len(funcs)
		for i, x := range funcs {
			cpp.LazyIfDef(x.Requires, func() {
				if x.VkFunctionPointer != nil {
					funcRes := `VKAPI_ATTR FORCE_INLINE ` + x.Return
					if x.HasReturn() {
						funcRes = "NODISCARD " + funcRes
					}
					cpp.Func(x.Name, funcRes, base.Stringize(x.Args...), "const", func() {
						argNames := base.Map(func(a VkFunctionArg) string { return re_vkIdentifier.FindString(a.Name) }, x.Args...)
						argList := strings.Join(argNames, ", ")
						funCall := fmt.Sprintf("%s->%s(%s)", ptr, x.Name, argList)
						cpp.Statement(fmt.Sprintf("VKLOG_APICALL(%s, %s)", x.Name, argList))
						if x.HasReturn() {
							cpp.Statement("return " + funCall)
						} else {
							cpp.Statement(funCall)
						}
					})
				}
			}, i+1 == n)
		}
	}

	cpp.Namespace("vk", func() {
		// api_version
		cpp.EnumC99("api_version", "uint32_t", func() {
			for _, x := range vk.Versions {
				cpp.Println("API_version_%s = %s,", x[len(x)-3:], x)
			}
			if len(vk.Versions) > 0 {
				cpp.Println("API_version_latest = %v,", vk.Versions[len(vk.Versions)-1])
			}
		})
		// extensions
		makeExtensionEnumDecl("instance_extension", vk.InstanceExts)
		makeExtensionEnumDecl("device_extension", vk.DeviceExts)
		cpp.Statement(`instance_extension_set instance_extensions_require(const device_extension_set& in)`)
		// exported_api
		cpp.Struct("DLL_EXPORT exported_api", func() {
			makePfnDecl(vk.ExportedFuncs)
		})
		// global_api
		cpp.Struct("DLL_EXPORT global_api", func() {
			cpp.Statement("static const global_api g_dummy")
			cpp.Statement("const exported_api* exported_api_{ nullptr }")
			cpp.Func("attach_return_error", "NODISCARD const char*", []string{"const exported_api* api"}, "", nil)
			makePfnDecl(vk.ExportedFuncs)
			makePfnDecl(vk.GlobalFuncs)
		})
		// instance_api
		cpp.Struct("DLL_EXPORT instance_api", func() {
			cpp.Statement("static const instance_api g_dummy")
			cpp.Statement("api_version version_{ API_version_latest }")
			cpp.Statement("const global_api* global_api_{ nullptr }")
			cpp.Statement("instance_extension_set instance_extensions_{}")
			cpp.Func("attach_return_error", "NODISCARD const char*", []string{
				"const global_api* api",
				"VkInstance vkInstance",
				"api_version version",
				"const instance_extension_set& required",
				"instance_extension_set optional = PPE::Default"}, "", nil)
			cpp.Func("setup_backward_compatibility", "void", []string{}, "", nil)
			makePfnDecl(vk.InstanceFuncs)
		})
		// instance_fn
		cpp.Struct("DLL_EXPORT instance_fn", func() {
			cpp.Println_NoIndent("protected:")
			cpp.Statement("friend struct device_api")
			cpp.Statement("const instance_api* instance_api_{ nullptr }")
			cpp.Println_NoIndent("public:")
			cpp.Statement("instance_fn() = default")
			cpp.Println("CONSTEXPR instance_fn(const instance_api* api) : instance_api_(api) {}")
			cpp.Func("api", "const instance_api*", []string{}, "const", func() {
				cpp.Statement("return instance_api_")
			})
			cpp.Func("version", "api_version", []string{}, "const", func() {
				cpp.Statement("return instance_api_->version_")
			})
			cpp.Func("instance_extensions", "const instance_extension_set&", []string{}, "const", func() {
				cpp.Statement("return instance_api_->instance_extensions_")
			})
			makePfnWrapper("instance_api_->global_api_->exported_api_", vk.ExportedFuncs)
			makePfnWrapper("instance_api_->global_api_", vk.GlobalFuncs)
			makePfnWrapper("instance_api_", vk.InstanceFuncs)
		})
		// device_api
		cpp.Struct("DLL_EXPORT device_api", func() {
			cpp.Statement("static const device_api g_dummy")
			cpp.Statement("const instance_api* instance_api_{ nullptr }")
			cpp.Statement("device_extension_set device_extensions_{}")
			cpp.Func("attach_return_error", "NODISCARD const char*", []string{
				"const instance_api* api",
				"VkDevice vkDevice",
				"const device_extension_set& required",
				"device_extension_set optional = PPE::Default"}, "", nil)
			cpp.Func("attach_return_error", "NODISCARD const char*", []string{
				"const instance_fn& fn",
				"VkDevice vkDevice",
				"const device_extension_set& required",
				"device_extension_set optional = PPE::Default"}, "", nil)
			cpp.Func("setup_backward_compatibility", "void", []string{}, "", nil)
			makePfnDecl(vk.DeviceFuncs)
		})
		// device_fn
		cpp.Struct("DLL_EXPORT device_fn", func() {
			cpp.Println_NoIndent("protected:")
			cpp.Statement("const device_api* device_api_{ nullptr }")
			cpp.Println_NoIndent("public:")
			cpp.Statement("device_fn() = default")
			cpp.Println("CONSTEXPR device_fn(const device_api* api) : device_api_(api) {}")
			cpp.Func("api", "const device_api*", []string{}, "const", func() {
				cpp.Statement("return device_api_")
			})
			cpp.Func("version", "api_version", []string{}, "const", func() {
				cpp.Statement("return device_api_->instance_api_->version_")
			})
			cpp.Func("device_extensions", "const device_extension_set&", []string{}, "const", func() {
				cpp.Statement("return device_api_->device_extensions_")
			})
			makePfnWrapper("device_api_->instance_api_", vk.InstanceFuncs)
			makePfnWrapper("device_api_", vk.DeviceFuncs)
		})
	})

	return nil
}

/***************************************
 * Vulkan generated source
 ***************************************/

var VulkanSourceVersion = "VulkanGeneratedSource-1.0.0"

type VulkanSourceGenerator struct {
	Version         string
	GeneratedHeader string
}

func (x *VulkanSourceGenerator) Serialize(ar base.Archive) {
	ar.String(&x.Version)
	ar.String(&x.GeneratedHeader)
}
func (x VulkanSourceGenerator) CreateGenerated(unit *compile.Unit, output utils.Filename) compile.Generated {
	return &VulkanGeneratedSource{
		Version:         x.Version,
		GeneratedHeader: x.GeneratedHeader,
		BindingsFile:    getVulkanBindingsFile(unit),
		IncludeDir:      getVulkanIncludeDir(unit),
	}
}

type VulkanGeneratedSource struct {
	Version         string
	GeneratedHeader string
	BindingsFile    utils.Filename
	IncludeDir      utils.Directory
}

func (x *VulkanGeneratedSource) Serialize(ar base.Archive) {
	ar.String(&x.Version)
	ar.String(&x.GeneratedHeader)
	ar.Serializable(&x.BindingsFile)
	ar.Serializable(&x.IncludeDir)
}
func (g VulkanGeneratedSource) Generate(bc utils.BuildContext, generated *compile.BuildGenerated, dst io.Writer) error {
	vk, err := GetVulkanInterface(VulkanInterfaceParams{g.IncludeDir, g.BindingsFile}).Need(bc)
	if err != nil {
		return err
	}

	cpp := internal_io.NewCppFile(dst, false)
	cpp.Comment("Vulkan source generated by %v - vulkan v%v", utils.CommandEnv.Prefix(), VulkanSourceVersion)
	cpp.Pragma("once")
	cpp.Include(g.GeneratedHeader)
	cpp.Include("IO/StringView.h")

	makeExtensionEnumDef := func(name string, exts []VkExtension) {
		cpp.Comment(name)
		cpp.Func(name+"_name", "const char*", []string{name + " ext"}, "", func() {
			cpp.Switch("ext", func() {
				for _, x := range exts {
					cpp.IfDef(x.Name, func() {
						cpp.Statement("case %s: return %s", getVkExtensionFlag(x.Name), x.Name)
					})
				}
				cpp.Statement("default: return nullptr")
			})
		})
		cpp.Func(name+"_from", name, []string{"const char* name"}, "", func() {
			cpp.Statement("using namespace PPE")
			cpp.Switch("hash_strI_constexpr(name)", func() {
				for _, x := range exts {
					cpp.IfDef(x.Name, func() {
						cpp.Println(`case hash_strI_constexpr(%s):`, x.Name)
						cpp.ScopeIndent(func() {
							cpp.Statement(`return (EqualsI(MakeCStringView(name), %s) ? %s : %s_unknown)`,
								x.Name, getVkExtensionFlag(x.Name), name)
						})
					})
				}
				cpp.Statement("default: return %s_unknown", name)
			})
		})
		cpp.Func(name+"s_available", name+"_set", []string{}, "", func() {
			cpp.Statement("%s_set avail{}", name)
			for _, x := range exts {
				cpp.IfDef(x.Name, func() {
					cpp.Statement("avail += %s", getVkExtensionFlag(x.Name))
				})
			}
			cpp.Statement("return avail")
		})
		cpp.Func(name+"s_require", name+"_set", []string{"const " + name + "_set& in"}, "", func() {
			cpp.Statement("%s_set required{ in }", name)
			for i := range exts {
				x := exts[len(exts)-1-i] // reverse order: assume extensions are sorted by dependencies
				if len(x.Requires) > 0 {
					cpp.IfDef(x.Name, func() {
						hasExt := fmt.Sprintf("in & %s", getVkExtensionFlag(x.Name))
						cpp.If(hasExt, func() {
							for _, req := range x.Requires {
								cpp.Statement("required += %s", getVkExtensionFlag(req))
							}
						})
					})
				}
			}
			cpp.Statement("return required")
		})
	}

	makePfnDummy := func(funcs []VkFunction) {
		n := len(funcs)
		for i, x := range funcs {
			cpp.LazyIfDef(x.Requires, func() {
				if x.VkFunctionPointer != nil {
					cpp.Print("/* %s */", x.Name)
					switch strings.ToUpper(x.Return) {
					case "VOID":
						cpp.Println("[](auto...) -> void {},")
					case "VKRESULT":
						var value string
						if len(x.Requires) > 0 {
							value = "VK_ERROR_EXTENSION_NOT_PRESENT"
						} else {
							value = "VK_NOT_READY"
						}
						cpp.Println("[](auto...) -> VkResult { return %s; },", value)
					case "VKBOOL32":
						cpp.Println("[](auto...) -> VkBool32 { return VK_FALSE; },")
					case "UINT64_T", "UINT32_T", "VKDEVICESIZE", "VKDEVICEADDRESS", "VKFLAGS":
						cpp.Println("[](auto...) -> %s { return 0; },", x.Return)
					default:
						cpp.Println("[](auto...) -> %s { return VK_NULL_HANDLE; },", x.Return)
					}
				}
			}, i+1 == n)
		}
	}

	cpp.Namespace("vk", func() {
		// helpers
		cpp.Println("template <typename _PFN>")
		cpp.Func("attach_pfn_", "NODISCARD FORCE_INLINE static bool", []string{
			"_PFN* outPFN",
			"const global_api& api",
			"const char* name"}, "", func() {
			cpp.Statement(`*outPFN = reinterpret_cast<_PFN>(api.exported_api_->vkGetInstanceProcAddr(VK_NULL_HANDLE, name))`)
			cpp.Statement(`return (!!*outPFN)`)
		})
		cpp.Println("template <typename _PFN>")
		cpp.Func("attach_pfn_", "NODISCARD FORCE_INLINE static bool", []string{
			"_PFN* outPFN",
			"const instance_api& api",
			"VkInstance vkInstance",
			"const char* name"}, "", func() {
			cpp.Statement(`*outPFN = reinterpret_cast<_PFN>(api.global_api_->exported_api_->vkGetInstanceProcAddr(vkInstance, name))`)
			cpp.Statement(`return (!!*outPFN)`)
		})
		cpp.Println("template <typename _PFN>")
		cpp.Func("attach_pfn_", "NODISCARD FORCE_INLINE static bool", []string{
			"_PFN* outPFN",
			"const device_api& api",
			"VkDevice vkDevice",
			"const char* name"}, "", func() {
			cpp.Statement(`*outPFN = reinterpret_cast<_PFN>(api.instance_api_->vkGetDeviceProcAddr(vkDevice, name))`)
			cpp.Statement(`return (!!*outPFN)`)
		})
		// extensions
		makeExtensionEnumDef("instance_extension", vk.InstanceExts)
		makeExtensionEnumDef("device_extension", vk.DeviceExts)
		// instance extensions require by each device extension
		cpp.Func("instance_extensions_require", "instance_extension_set", []string{"const device_extension_set& in"}, "", func() {
			cpp.Statement("instance_extension_set required{ PPE::Meta::ForceInit }")
			for i := range vk.DeviceExts {
				x := vk.DeviceExts[len(vk.DeviceExts)-1-i] // reverse order: assume extensions are sorted by dependencies
				if len(x.Foreign) > 0 {
					cpp.IfDef(x.Name, func() {
						hasExt := fmt.Sprintf("in & %s", getVkExtensionFlag(x.Name))
						cpp.If(hasExt, func() {
							for _, req := range x.Foreign {
								cpp.Statement("required += %s", getVkExtensionFlag(req))
							}
						})
					})
				}
			}
			cpp.Statement("return required")
		})
		// global_api
		cpp.Declare("global_api::g_dummy", "const global_api", func() {
			cpp.Println("nullptr/* exported_api_ */,")
			makePfnDummy(vk.ExportedFuncs)
			makePfnDummy(vk.GlobalFuncs)
		})
		cpp.Func("global_api::attach_return_error", "const char*", []string{"const exported_api* api"}, "", func() {
			cpp.Statement("exported_api_ = api")
			for i, x := range vk.ExportedFuncs {
				cpp.LazyIfDef(x.Requires, func() {
					if x.VkFunctionPointer != nil {
						available := fmt.Sprintf("nullptr == (%v = api->%v)", x.Name, x.Name)
						cpp.If(available, func() {
							cpp.Statement(`return "%v"`, x.Name)
						})
					}
				}, i+1 == len(vk.GlobalFuncs))
			}
			for i, x := range vk.GlobalFuncs {
				cpp.LazyIfDef(x.Requires, func() {
					if x.VkFunctionPointer != nil {
						available := fmt.Sprintf(`!attach_pfn_(&%s, *this, "%s")`, x.Name, x.Name)
						cpp.If(available, func() {
							cpp.Statement(`return "%v"`, x.Name)
						})
					}
				}, i+1 == len(vk.ExportedFuncs))
			}
			cpp.Statement("return nullptr/* no error */")
		})
		// instance_api
		cpp.Declare("instance_api::g_dummy", "const instance_api", func() {
			cpp.Println("API_version_latest,")
			cpp.Println("nullptr/* global_api_ */,")
			cpp.Println("{ PPE::Meta::ForceInit }/* instance_extensions_ */,")
			makePfnDummy(vk.InstanceFuncs)
		})
		cpp.Func("instance_api::attach_return_error", "const char*", []string{
			"const global_api* api",
			"VkInstance vkInstance",
			"api_version version",
			"const instance_extension_set& required",
			"instance_extension_set optional"}, "", func() {
			cpp.Statement("version_ = version")
			cpp.Statement("global_api_ = api")
			cpp.Statement("const instance_extension_set user = required | optional")
			cpp.Statement("instance_extensions_ = user")
			for i, x := range vk.InstanceFuncs {
				cpp.LazyIfDef(x.Requires, func() {
					if x.VkFunctionPointer != nil {
						if x.Requires == "" {
							available := fmt.Sprintf(
								`(version_ >= %s) && `+
									`!attach_pfn_(&%s, *this, vkInstance, "%s")`,
								getVkExtensionFlag(x.Version), x.Name, x.Name)
							cpp.If(available, func() {
								cpp.Statement(`return "%v"`, x.Name)
							})
						} else {
							flag := getVkExtensionFlag(x.Requires)
							available := fmt.Sprintf(
								`(user & %s) && `+
									`!attach_pfn_(&%s, *this, vkInstance, "%s")`,
								flag, x.Name, x.Name)
							cpp.If(available, func() {
								cpp.Statement("instance_extensions_ -= %v", flag)
								cpp.Statement(`if (required & %v) return "%v"`, flag, x.Name)
								cpp.Statement(`%v = g_dummy.%v`, x.Name, x.Name)
							})
						}
					}
				}, i+1 == len(vk.InstanceFuncs))
			}
			cpp.Statement("return nullptr/* no error */")
		})
		cpp.Func("instance_api::setup_backward_compatibility", "void", []string{}, "", func() {
			cpp.Statement("const uint32_t vkVersion = static_cast<uint32_t>(version_)")
			cpp.Statement("PPE::Unused(vkVersion)")
			for i, x := range vk.InstanceBwds {
				from := vk.InstanceFuncs[x.From]
				to := vk.InstanceFuncs[x.To]
				available := fmt.Sprintf("defined(%s) && defined(%v)", x.Version, from.Requires)
				cpp.LazyIfMacro(available, func() {
					available := fmt.Sprintf("vkVersion >= %v", x.Version)
					cpp.If(available, func() {
						cpp.Statement("Assert(%s)", to.Name)
						cpp.Statement("%s = %s", from.Name, to.Name)
					})
				}, i+1 == len(vk.InstanceBwds))
			}
		})
		// device_api
		cpp.Declare("device_api::g_dummy", "const device_api", func() {
			cpp.Println("nullptr/* instance_api_ */,")
			cpp.Println("{ PPE::Meta::ForceInit }/* device_extensions_ */,")
			makePfnDummy(vk.DeviceFuncs)
		})
		cpp.Func("device_api::attach_return_error", "const char*", []string{
			"const instance_api* api",
			"VkDevice vkDevice",
			"const device_extension_set& required",
			"device_extension_set optional"}, "", func() {
			cpp.Statement("instance_api_ = api")
			cpp.Statement("const device_extension_set user = required | optional")
			cpp.Statement("device_extensions_ = user")
			for i, x := range vk.DeviceFuncs {
				cpp.LazyIfDef(x.Requires, func() {
					if x.VkFunctionPointer != nil {
						if x.Requires == "" {
							available := fmt.Sprintf(
								`(instance_api_->version_ >= %s) && `+
									`!attach_pfn_(&%s, *this, vkDevice, "%s")`,
								getVkExtensionFlag(x.Version), x.Name, x.Name)
							cpp.If(available, func() {
								cpp.Statement(`return "%v"`, x.Name)
							})
						} else {
							flag := getVkExtensionFlag(x.Requires)
							available := fmt.Sprintf(
								`(user & %s) && `+
									`!attach_pfn_(&%s, *this, vkDevice, "%s")`,
								flag, x.Name, x.Name)
							cpp.If(available, func() {
								cpp.Statement("device_extensions_ -= %v", flag)
								cpp.Statement(`if (required & %v) return "%v"`, flag, x.Name)
								cpp.Statement(`%v = g_dummy.%v`, x.Name, x.Name)
							})
						}
					}
				}, i+1 == len(vk.DeviceFuncs))
			}
			cpp.Statement("return nullptr/* no error */")
		})
		cpp.Func("device_api::attach_return_error", "const char*", []string{
			"const instance_fn& fn",
			"VkDevice vkDevice",
			"const device_extension_set& required",
			"device_extension_set optional"}, "", func() {
			cpp.Statement("return attach_return_error(fn.instance_api_, vkDevice, required, optional)")
		})
		cpp.Func("device_api::setup_backward_compatibility", "void", []string{}, "", func() {
			cpp.Statement("const uint32_t vkVersion = static_cast<uint32_t>(instance_api_->version_)")
			cpp.Statement("PPE::Unused(vkVersion)")
			for i, x := range vk.DeviceBwds {
				from := vk.DeviceFuncs[x.From]
				to := vk.DeviceFuncs[x.To]
				available := fmt.Sprintf("defined(%s) && defined(%v)", x.Version, from.Requires)
				cpp.LazyIfMacro(available, func() {
					available := fmt.Sprintf("vkVersion >= %v", x.Version)
					cpp.If(available, func() {
						cpp.Statement("Assert(%s)", to.Name)
						cpp.Statement("%s = %s", from.Name, to.Name)
					})
				}, i+1 == len(vk.DeviceBwds))
			}
		})
	})

	return nil
}

/***************************************
 * Vulkan API parsing
 ***************************************/

func getVkExtensionFlag(macro string) (flag string) {
	flag = strings.TrimSuffix(macro, "_EXTENSION_NAME")
	flag = strings.TrimPrefix(flag, "VK_")
	sep := strings.Index(flag, "_")
	return flag[:sep] + "_" + strings.ToLower(flag[sep+1:])
}

func getVkVersionFlag(macro string) (flag string) {
	flag = strings.TrimPrefix(macro, "VK_")
	sep := strings.Index(flag, "_")
	return flag[:sep] + "_" + strings.ToLower(flag[sep+1:])
}

type VkBindingType string

const (
	VK_EXPORTED_FUNCTION                      VkBindingType = "VK_EXPORTED_FUNCTION"
	VK_GLOBAL_LEVEL_FUNCTION                  VkBindingType = "VK_GLOBAL_LEVEL_FUNCTION"
	VK_INSTANCE_LEVEL_FUNCTION                VkBindingType = "VK_INSTANCE_LEVEL_FUNCTION"
	VK_INSTANCE_LEVEL_EXTENSION               VkBindingType = "VK_INSTANCE_LEVEL_EXTENSION"
	VK_INSTANCE_LEVEL_FUNCTION_FROM_EXTENSION VkBindingType = "VK_INSTANCE_LEVEL_FUNCTION_FROM_EXTENSION"
	VK_INSTANCE_LEVEL_BACKWARD_COMPATIBILITY  VkBindingType = "VK_INSTANCE_LEVEL_BACKWARD_COMPATIBILITY"
	VK_DEVICE_LEVEL_FUNCTION                  VkBindingType = "VK_DEVICE_LEVEL_FUNCTION"
	VK_DEVICE_LEVEL_EXTENSION                 VkBindingType = "VK_DEVICE_LEVEL_EXTENSION"
	VK_DEVICE_LEVEL_FUNCTION_FROM_EXTENSION   VkBindingType = "VK_DEVICE_LEVEL_FUNCTION_FROM_EXTENSION"
	VK_DEVICE_LEVEL_BACKWARD_COMPATIBILITY    VkBindingType = "VK_DEVICE_LEVEL_BACKWARD_COMPATIBILITY"
)

func (v VkBindingType) String() string {
	return (string)(v)
}
func (v *VkBindingType) Set(in string) (err error) {
	switch strings.ToUpper(in) {
	case VK_EXPORTED_FUNCTION.String():
		*v = VK_EXPORTED_FUNCTION
	case VK_GLOBAL_LEVEL_FUNCTION.String():
		*v = VK_GLOBAL_LEVEL_FUNCTION
	case VK_INSTANCE_LEVEL_FUNCTION.String():
		*v = VK_INSTANCE_LEVEL_FUNCTION
	case VK_INSTANCE_LEVEL_EXTENSION.String():
		*v = VK_INSTANCE_LEVEL_EXTENSION
	case VK_INSTANCE_LEVEL_FUNCTION_FROM_EXTENSION.String():
		*v = VK_INSTANCE_LEVEL_FUNCTION_FROM_EXTENSION
	case VK_INSTANCE_LEVEL_BACKWARD_COMPATIBILITY.String():
		*v = VK_INSTANCE_LEVEL_BACKWARD_COMPATIBILITY
	case VK_DEVICE_LEVEL_FUNCTION.String():
		*v = VK_DEVICE_LEVEL_FUNCTION
	case VK_DEVICE_LEVEL_EXTENSION.String():
		*v = VK_DEVICE_LEVEL_EXTENSION
	case VK_DEVICE_LEVEL_FUNCTION_FROM_EXTENSION.String():
		*v = VK_DEVICE_LEVEL_FUNCTION_FROM_EXTENSION
	case VK_DEVICE_LEVEL_BACKWARD_COMPATIBILITY.String():
		*v = VK_DEVICE_LEVEL_BACKWARD_COMPATIBILITY
	default:
		err = base.MakeUnexpectedValueError(v, in)
	}
	return err
}
func (v *VkBindingType) Serialize(ar base.Archive) {
	ar.String((*string)(v))
}

type VkBinding struct {
	Kind VkBindingType
	Args base.StringSet
}

func (b VkBinding) String() string {
	return fmt.Sprintf("%s(%s)",
		b.Kind, strings.Join(b.Args, ", "))
}
func (b *VkBinding) Serialize(ar base.Archive) {
	ar.Serializable(&b.Kind)
	ar.Serializable(&b.Args)
}

type VkEnumValue struct {
	Key   string
	Value int32
}

func (x *VkEnumValue) Serialize(ar base.Archive) {
	ar.String(&x.Key)
	ar.Int32(&x.Value)
}

type VkEnum struct {
	Name   string
	Values []VkEnumValue
}

func (x *VkEnum) Serialize(ar base.Archive) {
	ar.String(&x.Name)
	base.SerializeSlice(ar, &x.Values)
}

type VkFunctionArg struct {
	Name string
	Type string
}

func (a VkFunctionArg) String() string {
	return fmt.Sprint(a.Type, " ", a.Name)
}
func (a *VkFunctionArg) Serialize(ar base.Archive) {
	ar.String(&a.Name)
	ar.String(&a.Type)
}

type VkFunctionPointer struct {
	Name   string
	Return string
	Args   []VkFunctionArg
}

func (f VkFunctionPointer) HasReturn() bool {
	return f.Return != "void"
}
func (f VkFunctionPointer) String() string {
	return fmt.Sprintf("typedef %s (VKAPI_PTR PFN_%s)(%s)",
		f.Return, f.Name, base.Join(", ", f.Args...))
}
func (f *VkFunctionPointer) Serialize(ar base.Archive) {
	ar.String(&f.Name)
	ar.String(&f.Return)
	base.SerializeSlice(ar, &f.Args)
}

/***************************************
 * Vulkan bindings
 ***************************************/

var re_vkComma = regexp.MustCompile(`\s*,\s*`)

func vkParseBindingArgs(in string) []string {
	return re_vkComma.Split(in, -1)
}

var re_VkBinding = regexp.MustCompile(`(?m)^\s*(VK_\w+)\s*\(\s*(.*?)\s*\)\s*$`)

func vkParseBindings(filename utils.Filename, match func(VkBinding)) error {
	return utils.UFS.Scan(filename, re_VkBinding, func(m []string) error {
		binding := VkBinding{
			Args: vkParseBindingArgs(m[1]),
		}
		if err := binding.Kind.Set(m[0]); err == nil {
			match(binding)
		} else {
			return err
		}
		return nil
	})
}

type VulkanBindings struct {
	Src      utils.Filename
	Bindings []VkBinding
}

func GetVulkanBindings(f utils.Filename) utils.BuildFactoryTyped[*VulkanBindings] {
	return utils.MakeBuildFactory(func(bi utils.BuildInitializer) (VulkanBindings, error) {
		return VulkanBindings{Src: f}, bi.NeedFile(f)
	})
}

func (vk *VulkanBindings) Alias() utils.BuildAlias {
	return utils.MakeBuildAlias("External", "Vulkan", vk.Src.Relative(utils.UFS.Root))
}
func (vk *VulkanBindings) Build(bc utils.BuildContext) error {
	vk.Bindings = []VkBinding{}
	err := vkParseBindings(vk.Src, func(vb VkBinding) {
		vk.Bindings = append(vk.Bindings, vb)
	})
	if err != nil {
		return err
	}

	base.LogTrace(LogGeneric, "vulkan: found %d bindings", len(vk.Bindings))
	return nil
}
func (vk *VulkanBindings) Serialize(ar base.Archive) {
	ar.Serializable(&vk.Src)
	base.SerializeSlice(ar, &vk.Bindings)
}

/***************************************
 * Vulkan headers
 ***************************************/

var re_vkSpace = regexp.MustCompile(`\s+`)

func vkParseFunctionArgs(in string) (result []VkFunctionArg) {
	for _, x := range re_vkComma.Split(in, -1) {
		it := re_vkSpace.Split(x, -1)
		result = append(result, VkFunctionArg{
			Name: it[len(it)-1],
			Type: strings.Join(it[:len(it)-1], " "),
		})
	}
	return result
}

var re_VkFunctionPointer = regexp.MustCompile(`(?m)^\s*typedef\s+(\w+\*?)\s+\(VKAPI_PTR\s+\*PFN_(\w+)\)\((.*?)\)\s*;\s*$`)

func vkParseFunctionPointers(filename utils.Filename) ([]VkFunctionPointer, error) {
	results := []VkFunctionPointer{}
	err := utils.UFS.Scan(filename, re_VkFunctionPointer, func(m []string) error {
		results = append(results, VkFunctionPointer{
			Return: m[0],
			Name:   m[1],
			Args:   vkParseFunctionArgs(m[2]),
		})
		return nil
	})
	return results, err
}

type VulkanHeaders struct {
	Src utils.Directory

	Headers   utils.FileSet
	Enums     []VkEnum
	Functions []VkFunctionPointer
}

func GetVulkanHeaders(src utils.Directory) utils.BuildFactoryTyped[*VulkanHeaders] {
	return utils.MakeBuildFactory(func(bi utils.BuildInitializer) (VulkanHeaders, error) {
		return VulkanHeaders{Src: src}, bi.NeedDirectory(src)
	})
}

func (vk *VulkanHeaders) Alias() utils.BuildAlias {
	return utils.MakeBuildAlias("External", "Vulkan", vk.Src.Relative(utils.UFS.Root))
}
func (vk *VulkanHeaders) Build(bc utils.BuildContext) error {
	vk.Headers = utils.FileSet{vk.Src.File("vulkan_core.h")}

	switch base.CurrentHost().Id {
	case base.HOST_DARWIN:
		vk.Headers.Append(vk.Src.File("vulkan_macos.h"))
	case base.HOST_LINUX:
		vk.Headers.Append(vk.Src.File("vulkan_xlib.h"))
	case base.HOST_WINDOWS:
		vk.Headers.Append(vk.Src.File("vulkan_win32.h"))
	default:
		base.UnexpectedValue(base.CurrentHost().Id)
	}

	if err := bc.NeedFile(vk.Headers...); err != nil {
		return err
	}

	if functions, err := base.ParallelMap(vkParseFunctionPointers, vk.Headers...); err == nil {
		for _, it := range functions {
			vk.Functions = append(vk.Functions, it...)
		}
	} else {
		return err
	}

	sort.Slice(vk.Functions, func(i, j int) bool {
		return vk.Functions[i].Name < vk.Functions[j].Name
	})

	base.LogTrace(LogGeneric, "vulkan: found %d headers", len(vk.Headers))
	base.LogTrace(LogGeneric, "vulkan: found %d functions", len(vk.Functions))

	return nil
}
func (vk *VulkanHeaders) Serialize(ar base.Archive) {
	ar.Serializable(&vk.Src)
	ar.Serializable(&vk.Headers)
	base.SerializeSlice(ar, &vk.Enums)
	base.SerializeSlice(ar, &vk.Functions)
}

/***************************************
 * Vulkan Interface
 ***************************************/
type VkExtension struct {
	Name      string
	Foreign   base.StringSet
	Requires  base.StringSet
	Aliases   []int32
	Functions []int32
}

func (ext *VkExtension) Serialize(ar base.Archive) {
	ar.String(&ext.Name)
	ar.Serializable(&ext.Foreign)
	ar.Serializable(&ext.Requires)
	base.SerializeMany(ar, ar.Int32, &ext.Aliases)
	base.SerializeMany(ar, ar.Int32, &ext.Functions)
}

type VkFunction struct {
	Requires string
	Version  string
	*VkFunctionPointer
}

func (fn *VkFunction) Serialize(ar base.Archive) {
	ar.String(&fn.Requires)
	ar.String(&fn.Version)
	base.SerializeExternal(ar, &fn.VkFunctionPointer)
}

type VkFunctionAlias struct {
	From, To int32
	Version  string
}

func (fn *VkFunctionAlias) Serialize(ar base.Archive) {
	ar.Int32(&fn.From)
	ar.Int32(&fn.To)
	ar.String(&fn.Version)
}

type VulkanInterface struct {
	BindingsFile utils.Filename
	IncludeDir   utils.Directory

	Headers  utils.FileSet
	Versions base.StringSet

	EnumTypes     []VkEnum
	ExportedFuncs []VkFunction
	GlobalFuncs   []VkFunction
	InstanceFuncs []VkFunction
	InstanceExts  []VkExtension
	InstanceBwds  []VkFunctionAlias
	DeviceFuncs   []VkFunction
	DeviceExts    []VkExtension
	DeviceBwds    []VkFunctionAlias
}

func (vk *VulkanInterface) GetHeaders(bc utils.BuildContext) (*VulkanHeaders, error) {
	return GetVulkanHeaders(vk.IncludeDir).Need(bc)
}
func (vk *VulkanInterface) GetBindings(bc utils.BuildContext) (*VulkanBindings, error) {
	return GetVulkanBindings(vk.BindingsFile).Need(bc)
}

type VulkanInterfaceParams struct {
	IncludeDir   utils.Directory
	BindingsFile utils.Filename
}

func (x VulkanInterfaceParams) Equals(other VulkanInterfaceParams) bool {
	return (x.IncludeDir.Equals(other.IncludeDir) && x.BindingsFile.Equals(other.BindingsFile))
}

func GetVulkanInterface(prms VulkanInterfaceParams) utils.BuildFactoryTyped[*VulkanInterface] {
	return utils.MakeBuildFactory(func(bi utils.BuildInitializer) (VulkanInterface, error) {
		return VulkanInterface{
				IncludeDir: prms.IncludeDir, BindingsFile: prms.BindingsFile,
			}, base.AnyError(
				bi.NeedDirectory(prms.IncludeDir),
				bi.NeedFile(prms.BindingsFile))
	})
}

func (vk *VulkanInterface) Alias() utils.BuildAlias {
	return utils.MakeBuildAlias("External", "Vulkan", "Interface")
}
func (vk *VulkanInterface) Build(bc utils.BuildContext) error {
	vkBindings, err := vk.GetBindings(bc)
	if err != nil {
		return err
	}
	vkHeaders, err := vk.GetHeaders(bc)
	if err != nil {
		return err
	}

	vk.Headers = vkHeaders.Headers

	funcPointerByName := make(map[string]int32, len(vkHeaders.Functions))
	for i, x := range vkHeaders.Functions {
		funcPointerByName[x.Name] = int32(i)
	}

	getFuncPointerByName := func(name string) *VkFunctionPointer {
		if i, ok := funcPointerByName[name]; ok {
			return &vkHeaders.Functions[i]
		} else {
			base.LogVerbose(LogGeneric, "vulkan: function not found: %s", name)
			return nil
		}
	}

	extensionFuncByName := make(map[string]int32)

	instanceExtByName := make(map[string]int32)
	getInstanceExtByName := func(name string) *VkExtension {
		if i, ok := instanceExtByName[name]; ok {
			return &vk.InstanceExts[i]
		} else {
			base.LogPanic(LogGeneric, "vulkan instance extension not found: %s", name)
			return nil
		}
	}

	deviceExtByName := make(map[string]int32)
	getDeviceExtByName := func(name string) *VkExtension {
		if i, ok := deviceExtByName[name]; ok {
			return &vk.DeviceExts[i]
		} else {
			base.LogVerbose(LogGeneric, "vulkan: device extension not found: %s", name)
			return nil
		}
	}

	vk.Versions = base.StringSet{}
	vk.EnumTypes = vkHeaders.Enums
	vk.ExportedFuncs = []VkFunction{}
	vk.GlobalFuncs = []VkFunction{}
	vk.InstanceFuncs = []VkFunction{}
	vk.InstanceExts = []VkExtension{}
	vk.InstanceBwds = []VkFunctionAlias{}
	vk.DeviceFuncs = []VkFunction{}
	vk.DeviceExts = []VkExtension{}
	vk.DeviceBwds = []VkFunctionAlias{}

	for _, x := range vkBindings.Bindings {
		base.LogVeryVerbose(LogGeneric, "%v(%v)", x.Kind, base.MakeStringer(func() string {
			return base.Join(", ", x.Args).String()
		}))
		switch x.Kind {
		case VK_INSTANCE_LEVEL_EXTENSION:
			instanceExtByName[x.Args[0]] = int32(len(vk.InstanceExts))
			vk.InstanceExts = append(vk.InstanceExts, VkExtension{
				Name:     x.Args[0],
				Requires: x.Args[1:],
			})
		case VK_DEVICE_LEVEL_EXTENSION:
			deviceExtByName[x.Args[0]] = int32(len(vk.DeviceExts))

			instanceExts := base.StringSet{}
			deviceExts := base.StringSet{}
			for _, ext := range x.Args[1:] {
				if _, ok := instanceExtByName[ext]; ok {
					instanceExts.Append(ext)
				} else {
					deviceExts.Append(ext)
				}
			}

			vk.DeviceExts = append(vk.DeviceExts, VkExtension{
				Name:     x.Args[0],
				Foreign:  instanceExts,
				Requires: deviceExts,
			})
		case VK_EXPORTED_FUNCTION:
			vk.ExportedFuncs = append(vk.ExportedFuncs, VkFunction{
				VkFunctionPointer: getFuncPointerByName(x.Args[0]),
			})
		case VK_GLOBAL_LEVEL_FUNCTION:
			vk.GlobalFuncs = append(vk.GlobalFuncs, VkFunction{
				VkFunctionPointer: getFuncPointerByName(x.Args[0]),
			})
		case VK_INSTANCE_LEVEL_FUNCTION:
			vk.Versions.AppendUniq(x.Args[1])
			extensionFuncByName[x.Args[0]] = int32(len(vk.InstanceFuncs))
			vk.InstanceFuncs = append(vk.InstanceFuncs, VkFunction{
				VkFunctionPointer: getFuncPointerByName(x.Args[0]),
				Version:           x.Args[1],
			})
		case VK_INSTANCE_LEVEL_FUNCTION_FROM_EXTENSION:
			instanceExt := getInstanceExtByName(x.Args[1])
			instanceExt.Functions = append(instanceExt.Functions, int32(len(vk.InstanceFuncs)))
			extensionFuncByName[x.Args[0]] = int32(len(vk.InstanceFuncs))
			vk.InstanceFuncs = append(vk.InstanceFuncs, VkFunction{
				Requires:          x.Args[1],
				VkFunctionPointer: getFuncPointerByName(x.Args[0]),
			})
		case VK_INSTANCE_LEVEL_BACKWARD_COMPATIBILITY:
			instanceExt := getInstanceExtByName(x.Args[4])
			instanceExt.Aliases = append(instanceExt.Aliases, int32(len(vk.InstanceBwds)))
			vk.InstanceBwds = append(vk.InstanceBwds, VkFunctionAlias{
				From:    extensionFuncByName[x.Args[2]],
				To:      extensionFuncByName[x.Args[3]],
				Version: fmt.Sprintf("VK_VERSION_%s_%s", x.Args[0], x.Args[1]),
			})
		case VK_DEVICE_LEVEL_FUNCTION:
			vk.Versions.AppendUniq(x.Args[1])
			extensionFuncByName[x.Args[0]] = int32(len(vk.DeviceFuncs))
			vk.DeviceFuncs = append(vk.DeviceFuncs, VkFunction{
				VkFunctionPointer: getFuncPointerByName(x.Args[0]),
				Version:           x.Args[1],
			})
		case VK_DEVICE_LEVEL_FUNCTION_FROM_EXTENSION:
			deviceExt := getDeviceExtByName(x.Args[1])
			deviceExt.Functions = append(deviceExt.Functions, int32(len(vk.DeviceFuncs)))
			extensionFuncByName[x.Args[0]] = int32(len(vk.DeviceFuncs))
			vk.DeviceFuncs = append(vk.DeviceFuncs, VkFunction{
				Requires:          x.Args[1],
				VkFunctionPointer: getFuncPointerByName(x.Args[0]),
			})
		case VK_DEVICE_LEVEL_BACKWARD_COMPATIBILITY:
			if deviceExt := getDeviceExtByName(x.Args[4]); deviceExt != nil {
				deviceExt.Aliases = append(deviceExt.Aliases, int32(len(vk.InstanceBwds)))
			}
			vk.DeviceBwds = append(vk.DeviceBwds, VkFunctionAlias{
				From:    extensionFuncByName[x.Args[2]],
				To:      extensionFuncByName[x.Args[3]],
				Version: fmt.Sprintf("VK_VERSION_%s_%s", x.Args[0], x.Args[1]),
			})
		default:
			base.UnexpectedValue(x.Kind)
		}
	}

	base.LogTrace(LogGeneric, "vulkan: found %d versions", len(vk.Versions))
	base.LogTrace(LogGeneric, "vulkan: found %d enum types", len(vk.EnumTypes))
	base.LogTrace(LogGeneric, "vulkan: found %d exported functions", len(vk.ExportedFuncs))
	base.LogTrace(LogGeneric, "vulkan: found %d global functions", len(vk.GlobalFuncs))
	base.LogTrace(LogGeneric, "vulkan: found %d instance functions", len(vk.InstanceFuncs))
	base.LogTrace(LogGeneric, "vulkan: found %d instance extensions", len(vk.InstanceExts))
	base.LogTrace(LogGeneric, "vulkan: found %d device functions", len(vk.DeviceFuncs))
	base.LogTrace(LogGeneric, "vulkan: found %d device extensions", len(vk.DeviceExts))
	return nil
}
func (vk *VulkanInterface) Serialize(ar base.Archive) {
	ar.Serializable(&vk.BindingsFile)
	ar.Serializable(&vk.IncludeDir)

	ar.Serializable(&vk.Headers)
	ar.Serializable(&vk.Versions)

	base.SerializeSlice(ar, &vk.EnumTypes)
	base.SerializeSlice(ar, &vk.ExportedFuncs)
	base.SerializeSlice(ar, &vk.GlobalFuncs)
	base.SerializeSlice(ar, &vk.InstanceFuncs)
	base.SerializeSlice(ar, &vk.InstanceExts)
	base.SerializeSlice(ar, &vk.InstanceBwds)
	base.SerializeSlice(ar, &vk.DeviceFuncs)
	base.SerializeSlice(ar, &vk.DeviceExts)
	base.SerializeSlice(ar, &vk.DeviceBwds)
}
